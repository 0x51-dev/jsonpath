// Package grammar is autogenerated by https://github.com/0x51-dev/upeg. DO NOT EDIT.
package grammar

import (
	"github.com/0x51-dev/upeg/parser"
	"github.com/0x51-dev/upeg/parser/op"
)

var (
	JsonpathQuery         = op.Capture{Name: "JsonpathQuery", Value: op.And{RootIdentifier, Segments}}
	Segments              = op.Capture{Name: "Segments", Value: op.ZeroOrMore{Value: op.And{S, Segment}}}
	B                     = op.Or{rune(0x20), rune(0x09), rune(0x0A), rune(0x0D)}
	S                     = op.ZeroOrMore{Value: B}
	RootIdentifier        = op.Capture{Name: "RootIdentifier", Value: '$'}
	Selector              = op.Capture{Name: "Selector", Value: op.Or{NameSelector, WildcardSelector, SliceSelector, IndexSelector, FilterSelector}}
	NameSelector          = op.Capture{Name: "NameSelector", Value: StringLiteral}
	StringLiteral         = op.Capture{Name: "StringLiteral", Value: op.Or{op.And{rune(0x22), op.ZeroOrMore{Value: DoubleQuoted}, rune(0x22)}, op.And{rune(0x27), op.ZeroOrMore{Value: SingleQuoted}, rune(0x27)}}}
	DoubleQuoted          = op.Capture{Name: "DoubleQuoted", Value: op.Or{Unescaped, rune(0x27), op.And{ESC, rune(0x22)}, op.And{ESC, Escapable}}}
	SingleQuoted          = op.Capture{Name: "SingleQuoted", Value: op.Or{Unescaped, rune(0x22), op.And{ESC, rune(0x27)}, op.And{ESC, Escapable}}}
	ESC                   = op.Capture{Name: "ESC", Value: rune(0x5C)}
	Unescaped             = op.Or{op.RuneRange{Min: 0x20, Max: 0x21}, op.RuneRange{Min: 0x23, Max: 0x26}, op.RuneRange{Min: 0x28, Max: 0x5B}, op.RuneRange{Min: 0x5D, Max: 0xD7FF}, op.RuneRange{Min: 0xE000, Max: 0x10FFFF}}
	Escapable             = op.Capture{Name: "Escapable", Value: op.Or{rune(0x62), rune(0x66), rune(0x6E), rune(0x72), rune(0x74), '/', '\\', op.And{rune(0x75), Hexchar}}}
	Hexchar               = op.Capture{Name: "Hexchar", Value: op.Or{NonSurrogate, op.And{HighSurrogate, '\\', rune(0x75), LowSurrogate}}}
	NonSurrogate          = op.Capture{Name: "NonSurrogate", Value: op.Or{op.And{op.Or{DIGIT, 'A', 'B', 'C', 'E', 'F'}, op.Repeat{Min: 3, Max: 3, Value: HEXDIG}}, op.And{'D', op.RuneRange{Min: 0x30, Max: 0x37}, op.Repeat{Min: 2, Max: 2, Value: HEXDIG}}}}
	HighSurrogate         = op.Capture{Name: "HighSurrogate", Value: op.And{'D', op.Or{'8', '9', 'A', 'B'}, op.Repeat{Min: 2, Max: 2, Value: HEXDIG}}}
	LowSurrogate          = op.Capture{Name: "LowSurrogate", Value: op.And{'D', op.Or{'C', 'D', 'E', 'F'}, op.Repeat{Min: 2, Max: 2, Value: HEXDIG}}}
	HEXDIG                = op.Capture{Name: "HEXDIG", Value: op.Or{DIGIT, 'A', 'B', 'C', 'D', 'E', 'F'}}
	WildcardSelector      = op.Capture{Name: "WildcardSelector", Value: '*'}
	IndexSelector         = op.Capture{Name: "IndexSelector", Value: Int}
	Int                   = op.Capture{Name: "Int", Value: op.Or{'0', op.And{op.Optional{Value: '-'}, DIGIT1, op.ZeroOrMore{Value: DIGIT}}}}
	DIGIT1                = op.RuneRange{Min: 0x31, Max: 0x39}
	SliceSelector         = op.Capture{Name: "SliceSelector", Value: op.And{op.Optional{Value: op.And{Start, S}}, ':', S, op.Optional{Value: op.And{End, S}}, op.Optional{Value: op.And{':', op.Optional{Value: op.And{S, Step}}}}}}
	Start                 = op.Capture{Name: "Start", Value: Int}
	End                   = op.Capture{Name: "End", Value: Int}
	Step                  = op.Capture{Name: "Step", Value: Int}
	FilterSelector        = op.Capture{Name: "FilterSelector", Value: op.And{'?', S, LogicalExpr}}
	LogicalExpr           = op.Capture{Name: "LogicalExpr", Value: LogicalOrExpr}
	LogicalOrExpr         = op.And{LogicalAndExpr, op.ZeroOrMore{Value: op.And{S, "||", S, LogicalAndExpr}}}
	LogicalAndExpr        = op.Capture{Name: "LogicalAndExpr", Value: op.And{BasicExpr, op.ZeroOrMore{Value: op.And{S, "&&", S, BasicExpr}}}}
	BasicExpr             = op.Capture{Name: "BasicExpr", Value: op.Or{ParenExpr, ComparisonExpr, TestExpr}}
	ParenExpr             = op.Capture{Name: "ParenExpr", Value: op.And{op.Optional{Value: op.And{LogicalNotOp, S}}, '(', S, op.Reference{Name: "LogicalExpr"}, S, ')'}}
	LogicalNotOp          = op.Capture{Name: "LogicalNotOp", Value: '!'}
	TestExpr              = op.Capture{Name: "TestExpr", Value: op.And{op.Optional{Value: op.And{LogicalNotOp, S}}, op.Or{FilterQuery, FunctionExpr}}}
	FilterQuery           = op.Or{RelQuery, op.Reference{Name: "JsonpathQuery"}}
	RelQuery              = op.Capture{Name: "RelQuery", Value: op.And{CurrentNodeIdentifier, op.Reference{Name: "Segments"}}}
	CurrentNodeIdentifier = op.Capture{Name: "CurrentNodeIdentifier", Value: '@'}
	ComparisonExpr        = op.Capture{Name: "ComparisonExpr", Value: op.And{Comparable, S, ComparisonOp, S, Comparable}}
	Literal               = op.Capture{Name: "Literal", Value: op.Or{Number, StringLiteral, True, False, Null}}
	Comparable            = op.Capture{Name: "Comparable", Value: op.Or{Literal, SingularQuery, FunctionExpr}}
	ComparisonOp          = op.Capture{Name: "ComparisonOp", Value: op.Or{"==", "!=", "<=", ">=", '<', '>'}}
	SingularQuery         = op.Or{RelSingularQuery, AbsSingularQuery}
	RelSingularQuery      = op.Capture{Name: "RelSingularQuery", Value: op.And{CurrentNodeIdentifier, SingularQuerySegments}}
	AbsSingularQuery      = op.Capture{Name: "AbsSingularQuery", Value: op.And{RootIdentifier, SingularQuerySegments}}
	SingularQuerySegments = op.Capture{Name: "SingularQuerySegments", Value: op.ZeroOrMore{Value: op.And{S, op.Or{NameSegment, IndexSegment}}}}
	NameSegment           = op.Capture{Name: "NameSegment", Value: op.Or{op.And{'[', NameSelector, ']'}, op.And{'.', MemberNameShorthand}}}
	IndexSegment          = op.Capture{Name: "IndexSegment", Value: op.And{'[', IndexSelector, ']'}}
	Number                = op.Capture{Name: "Number", Value: op.And{op.Or{Int, "-0"}, op.Optional{Value: Frac}, op.Optional{Value: Exp}}}
	Frac                  = op.Capture{Name: "Frac", Value: op.And{'.', op.OneOrMore{Value: DIGIT}}}
	Exp                   = op.Capture{Name: "Exp", Value: op.And{'e', op.Optional{Value: op.Or{'-', '+'}}, op.OneOrMore{Value: DIGIT}}}
	True                  = op.Capture{Name: "True", Value: op.And{rune(0x74), rune(0x72), rune(0x75), rune(0x65)}}
	False                 = op.Capture{Name: "False", Value: op.And{rune(0x66), rune(0x61), rune(0x6c), rune(0x73), rune(0x65)}}
	Null                  = op.Capture{Name: "Null", Value: op.And{rune(0x6e), rune(0x75), rune(0x6c), rune(0x6c)}}
	FunctionName          = op.Capture{Name: "FunctionName", Value: op.And{FunctionNameFirst, op.ZeroOrMore{Value: FunctionNameChar}}}
	FunctionNameFirst     = LCALPHA
	FunctionNameChar      = op.Or{FunctionNameFirst, '_', DIGIT}
	LCALPHA               = op.RuneRange{Min: 0x61, Max: 0x7A}
	FunctionExpr          = op.Capture{Name: "FunctionExpr", Value: op.And{FunctionName, '(', S, op.Optional{Value: op.And{FunctionArgument, op.ZeroOrMore{Value: op.And{S, ',', S, FunctionArgument}}}}, S, ')'}}
	FunctionArgument      = op.Capture{Name: "FunctionArgument", Value: op.Or{Literal, FilterQuery, op.Reference{Name: "LogicalExpr"}, op.Reference{Name: "FunctionExpr"}}}
	Segment               = op.Capture{Name: "Segment", Value: op.Or{ChildSegment, DescendantSegment}}
	ChildSegment          = op.Capture{Name: "ChildSegment", Value: op.Or{BracketedSelection, op.And{'.', op.Or{WildcardSelector, MemberNameShorthand}}}}
	BracketedSelection    = op.Capture{Name: "BracketedSelection", Value: op.And{'[', S, Selector, op.ZeroOrMore{Value: op.And{S, ',', S, Selector}}, S, ']'}}
	MemberNameShorthand   = op.Capture{Name: "MemberNameShorthand", Value: op.And{NameFirst, op.ZeroOrMore{Value: NameChar}}}
	NameFirst             = op.Or{ALPHA, '_', op.RuneRange{Min: 0x80, Max: 0xD7FF}, op.RuneRange{Min: 0xE000, Max: 0x10FFFF}}
	NameChar              = op.Or{NameFirst, DIGIT}
	DIGIT                 = op.RuneRange{Min: 0x30, Max: 0x39}
	ALPHA                 = op.Or{op.RuneRange{Min: 0x41, Max: 0x5A}, op.RuneRange{Min: 0x61, Max: 0x7A}}
	DescendantSegment     = op.Capture{Name: "DescendantSegment", Value: op.And{"..", op.Or{BracketedSelection, WildcardSelector, MemberNameShorthand}}}
)

func NewParser(input []rune) (*parser.Parser, error) {
	p, err := parser.New(input)
	if err != nil {
		return nil, err
	}
	p.Rules["JsonpathQuery"] = JsonpathQuery
	p.Rules["Segments"] = Segments
	p.Rules["LogicalExpr"] = LogicalExpr
	p.Rules["FunctionExpr"] = FunctionExpr
	return p, nil
}
